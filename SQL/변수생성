================================================================================================================
원하는 결과는 아래와 같다. ANIMAL_OUTS 테이블에 없는 값(ex. hour의 0과 1)을 만들고, 해당 시간의 개수를 샌다.
----------------------------------------------------------------------------------------------------------------
hour   count
0      0 
1      0
2      3
3      4
...
23     2
----------------------------------------------------------------------------------------------------------------
아래 쿼리에서 생각되는 문제점은 @hour은 ANIMAL_OUTS에 종속되고 있다.
그래서 만약 테이블에 데이터가 10개라면, 만들 수 있는 hour의 범위는 0 ~ 10다. 
그렇다면, 0~23시를 만들어야 하는 문제 조건에 위배된다.
----------------------------------------------------------------------------------------------------------------
SET @hour := -1;

SELECT (@hour := @hour + 1) as HOUR,
(SELECT COUNT(*) FROM ANIMAL_OUTS WHERE HOUR(DATETIME) = @hour) as COUNT
FROM ANIMAL_OUTS
WHERE @hour < 23;
----------------------------------------------------------------------------------------------------------------
[대안] WITH RECURSIVE를 사용한다 => "https://velog.io/@jinseock95/프로그래머스MySQL3.GROUP-BY-입양-시각-구하기2"에서 사용법을 잘 설명하고 있다.
- WITH RECURSIVE: 함께 실행되늰 재귀 쿼리다. (?)
- UNION ALL은 테이블 간 행을 합친다. UNION은 중복된 행을 제거하지만, UNION ALL은 중복된 행을 허용한다.
- COALESCE: 주어진 인수에서 NULL이 아닌 첫 번째 값을 반환한다.
----------------------------------------------------------------------------------------------------------------
WITH RECURSIVE HOUR AS(
SELECT 0 AS h 
UNION ALL
SELECT h+1 FROM HOUR WHERE h<30)

SELECT h AS HOUR, COALESCE(COUNT(ANIMAL_ID),0) AS COUNT
FROM HOUR LEFT JOIN ANIMAL_OUTS ANI ON HOUR.h = HOUR(ANI.DATETIME)
GROUP BY HOUR.h;
================================================================================================================
