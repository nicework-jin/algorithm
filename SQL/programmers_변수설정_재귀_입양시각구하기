================================================================================================================
원하는 결과는 아래와 같다. ANIMAL_OUTS 테이블에 없는 값(ex. hour의 0과 1)을 만들고, 해당 시간의 개수를 샌다.
----------------------------------------------------------------------------------------------------------------
hour   count
0      0 
1      0
2      3
3      4
...
23     2
----------------------------------------------------------------------------------------------------------------
아래 쿼리에서 생각되는 문제점은 @hour은 ANIMAL_OUTS에 종속되고 있다.
그래서 만약 테이블에 데이터가 10개라면, 만들 수 있는 hour의 범위는 0 ~ 10다. 
그렇다면, 0~23시를 만들어야 하는 문제 조건에 위배된다.
----------------------------------------------------------------------------------------------------------------
SET @hour := -1;

SELECT (@hour := @hour + 1) as HOUR,
(SELECT COUNT(*) FROM ANIMAL_OUTS WHERE HOUR(DATETIME) = @hour) as COUNT
FROM ANIMAL_OUTS
WHERE @hour < 23;
----------------------------------------------------------------------------------------------------------------
[대안] WITH RECURSIVE를 사용한다 => "https://velog.io/@jinseock95/프로그래머스MySQL3.GROUP-BY-입양-시각-구하기2"에서 사용법을 잘 설명하고 있다.
- WITH RECURSIVE: 함께 실행되늰 재귀 쿼리다. (?)
- UNION ALL은 테이블 간 행을 합친다. UNION은 중복된 행을 제거하지만, UNION ALL은 중복된 행을 허용한다.
- COALESCE: 주어진 인수에서 NULL이 아닌 첫 번째 값을 반환한다.  => 이 경우에는 COALESCE를 사용할 필요가 없다. COUNT 결과이므로 어차피 0으로 주어지기 때문.
    COALESCE에 대한 말이 어려우니까. 아래 블로그에서 예제 캡처한 내용 확인.
    https://crazykim2.tistory.com/277
----------------------------------------------------------------------------------------------------------------
WITH RECURSIVE HOUR AS(
SELECT 0 AS h 
UNION ALL
SELECT h+1 FROM HOUR WHERE h<30)

SELECT h AS HOUR, COALESCE(COUNT(ANIMAL_ID),0) AS COUNT
FROM HOUR LEFT JOIN ANIMAL_OUTS ANI ON HOUR.h = HOUR(ANI.DATETIME)
GROUP BY HOUR.h;
----------------------------------------------------------------------------------------------------------------
[WITH RECURSIVE 골격 분석]
- WITH RECURSIVE 다음에 나오는 HOUR이 테이블로 사용된다. Alias 안에 union 쿼리를 반드시 넣는다.
- SELECT 0을 하면, 컬럼명이 0, 값이 0으로 출력된다. UNION ALL 과정에서 두 쿼리 결과가 행간 합쳐진 것이다.

WITH RECURSIVE로 생성된 테이블은 원하는 테이블과 JOIN하여 사용할 수 있다.
이 때, 재귀를 통해 생성을 기준으로 조인한다. (검토된 내용 아님.)
----------------------------------------------------------------------------------------------------------------
WITH RECURSIVE HOUR AS (
    SELECT 0 AS H
        UNION ALL
    SELECT H + 1
    FROM HOUR WHERE H < 23)

SELECT H
FROM HOUR
================================================================================================================
